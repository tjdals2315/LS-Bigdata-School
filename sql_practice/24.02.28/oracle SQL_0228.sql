-- 주석 = CTRL + /
-- 실습 데이터 살펴보기
-- 테이블 구조 보기
-- 사원정보
DESC EMP;
-- 부서정보
DESC DEPT;
-- 급여등급정보
DESC SALGRADE;
-- 테이블 조회(DQL, Data Query Language)
--SQL 기본 문법
--SELECT ~ FROM ~
--SELECT 열 이름(=컬럼 = 변수 = 필드) FROM 테이블 이름(데이터)
--변수
--문자(숫자로 코딩되어 있으나 숫자 의미가 없음) = 범주형 변수 = 빈도(비율)
--숫자 = 연속형 변수 = 평균
--모든 열 조회(*)
SELECT * FROM EMP;
--14개의 행 * 8개의 열 구조
SELECT * FROM DEPT;
--4개의 행 * 3개의 열 구조
SELECT * FROM SALGRADE;
--5개의 행 * 3개의 열 구조
--특정 열 조회
SELECT ENAME FROM EMP;
SELECT SAL FROM EMP;
SELECT ENAME, JOB FROM EMP;
SELECT ENAME, SAL FROM EMP;
SELECT EMPNO, ENAME, DEPTNO FROM EMP;
--가독성을 위해 줄바꿈을 할 수 있음
SELECT EMPNO,
       ENAME,
       DEPTNO
    FROM EMP;
--중복 제거
--내가 중복제거 원하는 열 앞에 작성
SELECT DEPTNO FROM EMP;
SELECT DISTINCT DEPTNO FROM EMP;
SELECT DISTINCT JOB, DEPTNO FROM EMP;
SELECT DISTINCT * FROM EMP; --전체행 중복제거
--별칭 설정하기
SELECT ENAME, SAL, COMM, SAL*12+COMM
    FROM EMP;
SELECT ENAME, SAL, COMM, SAL*12+COMM AS ANNSAL
    FROM EMP;
SELECT ENAME, SAL, COMM, SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+COMM
    FROM EMP;
SELECT ENAME, SAL, COMM, SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+COMM AS ANNSAL
    FROM EMP;
--오름차순
SELECT * FROM EMP ORDER BY SAL;
SELECT * FROM EMP ORDER BY ASC;
--내림차순
SELECT * FROM EMP ORDER BY SAL DESC;
--
SELECT * FROM EMP ORDER BY EMPNO;
SELECT * FROM EMP ORDER BY EMPNO ASC;
--
SELECT * FROM EMP ORDER BY EMPNO DESC;
--두개 사용 DEPTNO(부서 번호) 먼저 오름차순 같은 번호 안에서 SAL가 내림차순 됨.
SELECT * FROM EMP ORDER BY DEPTNO ASC, SAL DESC;
--줄바꿈
SELECT * 
    FROM EMP 
  ORDER BY DEPTNO ASC, 
           SAL DESC;
--WHERE절
SELECT * FROM EMP;
SELECT * FROM EMP WHERE DEPTNO = 30;
SELECT * FROM EMP WHERE EMPNO = 7782;

--AND = 교집합
SELECT * FROM EMP WHERE DEPTNO = 30 AND JOB = 'SALESMAN';
SELECT * FROM EMP WHERE DEPTNO = 30 AND EMPNO = 7499;
--OR = 합집합
SELECT * FROM EMP WHERE DEPTNO = 30 OR JOB = 'SALESMAN';
SELECT * FROM EMP WHERE DEPTNO = 20 OR JOB = 'SALESMAN';

--산술연산자
SELECT * FROM EMP WHERE SAL * 12 = 36000;

--비교연산자
SELECT * FROM EMP WHERE SAL >= 3000;
SELECT * FROM EMP WHERE SAL >= 3000 AND JOB = 'ANALYST';
SELECT * FROM EMP WHERE SAL >= 2500 AND JOB = 'ANALYST';

--문자비교연산자
--F~Z
SELECT * FROM EMP WHERE ENAME >= 'F';
--S~Z
SELECT * FROM EMP WHERE ENAME >= 'S';
--A~E
SELECT * FROM EMP WHERE ENAME < 'F';
--
SELECT * FROM EMP WHERE ENAME <= 'FORZ'; --첫글자가 다 F 앞에나옴, 두번째글자 R포함 R보다 앞에나오는 모든 문자...

--등가비교연산자
SELECT * FROM EMP WHERE SAL != 3000;
SELECT * FROM EMP WHERE SAL <> 3000;
SELECT * FROM EMP WHERE SAL ^= 3000;
--
--논리부정연산자
SELECT * FROM EMP WHERE NOT SAL = 3000;

----IN연산자
SELECT * FROM EMP WHERE JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';
SELECT * FROM EMP WHERE JOB IN ('MANAGER','SALESMAN','CLERK');
--NOT IN
SELECT * FROM EMP WHERE JOB != 'MANAGER' AND JOB != 'SALESMAN' AND JOB != 'CLERK';
SELECT * FROM EMP WHERE JOB NOT IN ('MANAGER','SALESMAN','CLERK');
--
SELECT * FROM EMP WHERE DEPTNO IN (10, 20);
SELECT * FROM EMP WHERE DEPTNO NOT IN (10, 20);

--BETWEEN
SELECT * FROM EMP WHERE SAL >= 2000 AND SAL <= 3000;
SELECT * FROM EMP WHERE SAL BETWEEN 2000 AND 3000;
--
SELECT * FROM EMP WHERE SAL < 2000 OR SAL > 3000;
SELECT * FROM EMP WHERE SAL NOT BETWEEN 2000 AND 3000;

--LIKE연산자 & 와일드카드
SELECT * FROM EMP WHERE ENAME LIKE 'S%'; -- 몇 글자여도 상관없이 다 찾음
SELECT * FROM EMP WHERE ENAME LIKE '_L%'; --첫글자는 아무거나 두번째 L이 들어가는 사람
SELECT * FROM EMP WHERE ENAME LIKE '%S%'; --앞뒤로 쓰면 S가 어디에 있어도 찾아줌
SELECT * FROM EMP WHERE ENAME LIKE '%AM%'; --이름에 AM이 있으면 찾는다.

--IS NULL연산자
SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM FROM EMP;
SELECT * FROM EMP WHERE COMM = NULL;
SELECT * FROM EMP WHERE COMM IS NULL;
SELECT * FROM EMP WHERE COMM IS NOT NULL;
--
--MGR 직속상관이 없는 사람
SELECT * FROM EMP WHERE MGR IS NULL;
--MGR 직속상관이 있는 사람
SELECT * FROM EMP WHERE MGR IS NOT NULL;
--

--IS NULL연산자
SELECT ENAME, SAL, SAL*12+COMM AS ANNSAL, COMM FROM EMP;
SELECT * FROM EMP WHERE COMM = NULL;
-- NULL 값을 찾는 방법
SELECT * FROM EMP WHERE COMM IS NULL;
SELECT * FROM EMP WHERE COMM IS NOT NULL; 
--
--MGR 직속상관이 없는 사람
SELECT * FROM EMP WHERE MGR IS NULL;
--MGR 직속상관이 있는 사람
SELECT * FROM EMP WHERE MGR IS NOT NULL;
--
SELECT * FROM EMP WHERE SAL > NULL AND COMM IS NULL;
SELECT * FROM EMP WHERE SAL > NULL OR COMM IS NULL; --IS NULL을 만족하는 것만 나옴
SELECT * FROM EMP WHERE COMM IS NULL;
--
--집합연산자
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 20;
--중복 제거하여 합집합
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 20;

--오류
--DEPTNO 누락
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = 20;
--열 순서 다름, 데이터 유형이 다름
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT ENAME, EMPNO, DEPTNO, SAL FROM EMP WHERE DEPTNO = 20;
--열 순서 다름
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT SAL, JOB, DEPTNO, SAL FROM EMP WHERE DEPTNO = 20;

--중복 제거되는지 확인
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
--중복 제거 없이 합치기
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10
UNION ALL
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;

--MINUS = 차집합
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP;
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;
--
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP
MINUS
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;

--INTERSECT = 교집합
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP
INTERSECT
SELECT EMPNO, ENAME, SAL, DEPTNO FROM EMP WHERE DEPTNO = 10;


--Q1
SELECT *FROM EMP WHERE ENAME LIKE 'S%';

--Q2
SELECT0 FROM EMP WHERE DEPTNO = 30 AND JOB = 'SALESMAN';

--Q3
SELECT * FROM EMP WHERE SAL > 2000;
SELECT * FROM EMP IS SAL > 2000;

--Q4
SELECT * FROM EMP WHERE SAL < 2000 OR SAL > 3000;
SELECT * FROM EMP WHERE SAL NOT BETWEEN 2000 AND 3000;

--문제5
SELECT ENAME, EMPNO, SAL, DEPTNO
    FROM EMP WHERE DEPTNO = 30 AND ENAME LIKE '%E%' AND SAL NOT BETWEEN 1000 AND 2000;

--문제6
SELECT * FROM EMP WHERE COMM IS NULL
                    AND MGR IS NOT NULL
                    AND JOB IN ('MANAGER','CLERK')
                    AND ENAME NOT LIKE '_L%';
--
--문자함수
SELECT ENAME, UPPER(ENAME), LOWER(ENAME), INITCAP(ENAME) FROM EMP;
--
SELECT * FROM EMP WHERE ENAME = 'scott';
SELECT * FROM EMP WHERE UPPER(ENAME) = UPPER('scott');
SELECT * FROM EMP WHERE UPPER(ENAME) LIKE UPPER('%scott%'); --문자 앞뒤 공백이 있을 수도 있기에 %를 앞뒤로 작성해줌
SELECT * FROM EMP WHERE UPPER(ENAME) LIKE UPPER('%am%');
--
SELECT * FROM EMP WHERE LOWER(ENAME) LIKE '%am%';
SELECT * FROM EMP WHERE UPPER(ENAME) LIKE '%AM%';
--

--문자열 길이
SELECT ENAME, LENGTH(ENAME) FROM EMP;
SELECT ENAME, LENGTH(ENAME) FROM EMP WHERE LENGTH(ENAME) >= 5;
SELECT ENAME, LENGTH(ENAME) FROM EMP WHERE LENGTH(ENAME) < 5;
--문자 바이트
SELECT LENGTH('AB'), LENGTHB('AB') FROM DUAL; --DUAL은 연산결과등을 확인하고 싶을때 사용하는 가상의 TABLE
SELECT LENGTH('이름'), LENGTHB('이름') FROM DUAL;
--
--문자열 일부 추출
SELECT JOB, SUBSTR(JOB, 1, 2), SUBSTR(JOB, 3, 2), SUBSTR(JOB, 5) FROM EMP;
SELECT ENAME, SUBSTR(ENAME, 3) FROM EMP; --숫자가 하나만 적혀있다면 3번째부터 끝까지 뽑는다.
--SUBSTR & LENGTH
SELECT JOB, LENGTH(JOB) FROM EMP;
--CLERK 1~5
-- -LENGTH('CLERK') -5~-1
SELECT JOB, SUBSTR(JOB, -LENGTH(JOB)), SUBSTR(JOB, -LENGTH(JOB), 2), SUBSTR(JOB, -3) FROM EMP;

--문자열 일부 추출
SELECT JOB, SUBSTR(JOB, 1, 2), SUBSTR(JOB, 3, 2), SUBSTR(JOB, 5) FROM EMP;
SELECT ENAME, SUBSTR(ENAME, 3) FROM EMP;
--SUBSTR & LENGTH
SELECT JOB, LENGTH(JOB) FROM EMP;
--CLERK 1~5
-- -LENGTH('CLERK') -5~-1
SELECT JOB, SUBSTR(JOB, -LENGTH(JOB)), SUBSTR(JOB, -LENGTH(JOB), 2), SUBSTR(JOB, -3) FROM EMP;

--특정 문자 위치
SELECT INSTR('HELLO, ORACLE!','L'),
       INSTR('HELLO, ORACLE!','L',5), -- 5는 시작위치를 뜻함 5번 이후에 나오는 'L'
       INSTR('HELLO, ORACLE!','L',2,2)--2번부터 시작해서 2번째 'L'
    FROM DUAL;
--
SELECT * FROM EMP WHERE ENAME LIKE '%S%';
SELECT * FROM EMP WHERE INSTR(ENAME, 'S') > 0;

--다른 문자로 대체
SELECT '010-1234-5678' AS REPLACE_BEFORE,
       REPLACE('010-1234-5678', '-', ' '),
       REPLACE('010-1234-5678', '-', '*'),
       REPLACE('010-1234-5678', '-')
    FROM DUAL;

--빈공간을 특정 문자로 채우는 함수
--왼쪽과 오른쪽 비어있는 곳을 채운다.
SELECT 'Oracle',
    LPAD('Oracle', 10, '#'),
    RPAD('Oracle', 10, '*'),
    LPAD('Oracle', 10),
    RPAD('Oracle', 10)
   FROM DUAL;
   
--문자열 합치기
SELECT EMPNO, ENAME FROM EMP WHERE ENAME = 'SCOTT';
SELECT CONCAT(EMPNO, ENAME) FROM EMP WHERE ENAME = 'SCOTT';
SELECT CONCAT(':',ENAME), CONCAT(EMPNO, CONCAT(':',ENAME)) FROM EMP WHERE ENAME = 'SCOTT';
--
SELECT EMPNO || ENAME FROM EMP WHERE ENAME = 'SCOTT'; --문자열 합치기
SELECT ':' || ENAME, EMPNO || ':' || ENAME FROM EMP WHERE ENAME = 'SCOTT';

--특정 문자를 지우는 함수
-- 앞으로 자주 쓰게될 함수임
--TRIM = 앞뒤 = TRIM(BOTH FROM
--LTRIM = 앞 = 왼쪽 = TRIM(LEADING FROM
--RTRIM = 뒤 = 오른쪽 = TRIM(TRAILING FROM
SELECT '['||' _ _Oracle_ _ '||']',
       '['||TRIM(' _ _Oracle_ _ ')||']', --BOTH FROM 생략되어 있음, 앞 뒤 공백 제거
       '['||TRIM(BOTH FROM ' _ _Oracle_ _ ')||']',
       '['||TRIM(LEADING FROM ' _ _Oracle_ _ ')||']', --LTRIM 왼쪽 공백제거
       '['||TRIM(TRAILING FROM ' _ _Oracle_ _ ')||']' --RTRIM 오른쪽 공백제거
    FROM DUAL;
--
--내가 어떤 문자를 지울지 결정할 수 있음
SELECT '['||'_ _Oracle_ _'||']',
       '['||TRIM('_' FROM '_ _Oracle_ _')||']',
       '['||TRIM(BOTH '_' FROM '_ _Oracle_ _')||']',
       '['||TRIM(LEADING '_' FROM '_ _Oracle_ _')||']',
       '['||TRIM(TRAILING '_' FROM '_ _Oracle_ _')||']'
    FROM DUAL;
--
-- 무엇을 지울 지 모른다면 공백을 지움
SELECT '['||' _Oracle_ '||']',
       '['||TRIM(' _Oracle_ ')||']',
       '['||LTRIM(' _Oracle_ ')||']',
       '['||RTRIM(' _Oracle_ ')||']'
    FROM DUAL;
--
SELECT '['||'<_Oracle_>'||']',
       '['||LTRIM('<_Oracle_>', '<_')||']', --순서상관없이 2개 기호 모두가 제거됨
       '['||LTRIM('<_Oracle_>', '_<')||']',
       '['||RTRIM('<_Oracle_>', '>_')||']',
       '['||RTRIM('<_Oracle_>', '_>')||']'
    FROM DUAL;
--
--숫자함수
--반올림
SELECT ROUND(1234.5678),
       ROUND(1234.5678, 0), --소수점이 0
       ROUND(1234.5678, 1), --소수점 한자리
       ROUND(1234.5678, 2), --소수점 두자리
       ROUND(1234.5678,-1), --첫번째 자리 반올림(4<5이므로 내림)
       ROUND(1234.5678, -2)
    FROM DUAL;
--버리기
SELECT TRUNC(1234.5678),
       TRUNC(1234.5678, 0),
       TRUNC(1234.5678, 1),
       TRUNC(1234.5678, 2),
       TRUNC(1234.5678,-1),
       TRUNC(1234.5678, -2)
    FROM DUAL;

-- 정수값반환
--CEIL : 큰 정수 값 = 3 < 3.14 < 4
--FLOOR : 작은 정수 값 = 3 < 3.14 < 4
--CEIL : 큰 정수 값 = -4 < -3.14 < -3
--FLOOR : 작은 정수 값 = -4 < 3.14 < -3
SELECT CEIL(3.14),
       FLOOR(3.14),
       CEIL(-3.14),
       FLOOR(-3.14)
    FROM DUAL; 
--나머지
SELECT MOD (15,6),
       MOD(10,2),
       MOD(11,2)
    FROM DUAL;
    
--날짜함수 -1 어제날짜, + 1 내일 날짜 (날짜와 날짜 빼기는 가능하지만 더하기는 불가능)
SELECT SYSDATE AS NOW,
       SYSDATE - 1 AS YESTERDAY,
       SYSDATE + 1 AS TOMORROW
    FROM DUAL;
--현재 날짜 기준 3개월 뒤가 궁금하면 ADD_MONTH 하면 오늘로부터 3개월 뒤
--개월수 추가
SELECT SYSDATE, ADD_MONTHS(SYSDATE, 3) FROM DUAL;
--입사 10주년
SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE, 120) AS WORK10YEARS FROM EMP;
--입사 41년 미만
SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE, 492), SYSDATE
    FROM EMP WHERE ADD_MONTHS(HIREDATE, 492) > SYSDATE;
--입사 41년 초과 (지난날짜)
SELECT EMPNO, ENAME, HIREDATE, ADD_MONTHS(HIREDATE, 492), SYSDATE
    FROM EMP WHERE ADD_MONTHS(HIREDATE, 492) < SYSDATE;
--과거 날짜는 작은 값, 미래 날짜는 큰 값!!!